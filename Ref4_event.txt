include::license.txt[]

:language: C

Working with events
-------------------
使用 events
-------------------

Libevent's basic unit of operation is the 'event'.  Every event
represents a set of conditions, including:

   - A file descriptor being ready to read from or write to.
   - A file descriptor _becoming_ ready to read from or write to
     (Edge-triggered IO only).
   - A timeout expiring.
   - A signal occurring.
   - A user-triggered event.

Libevent的基础执行单位是'event'。每个event代表一组条件，包括:
   - 当一个文件描述符已经准备好可读或者可写时
   - 当一个文件描述符将要可读或者可写时(只适用于电平触发的IO复用)
   - 当一个定时器到期触发时
   - 当触发了一个信号时
   - 用户主动触发时

Events have similar lifecycles.  Once you call a Libevent function to
set up an event and associate it with an event base, it becomes
*initialized*.  At this point, you can 'add', which makes it
*pending* in the base.  When the event is pending, if the conditions
that would trigger an event occur (e.g., its file descriptor changes
state or its timeout expires), the event becomes *active*, and its
(user-provided) callback function is run.  If the event is configured
*persistent*, it remains pending.  If it is not persistent, it stops
being pending when its callback runs.  You can make a pending event
non-pending by 'deleting' it, and you can 'add' a non-pending event to
make it pending again.

Events拥有相似的生命周期。当你调用一个Libevent函数设置一个事件并将它与一个event base关联，
它就被*初始化*了。此时，你可以'add'，这样这个event就在base中处于*待触发状态*。当event处于
待触发状态时，当能够触发这个event的条件发生时(比如，文件描述符状态改变，或者定时器触发)，这
个event就变成*激活状态*，并且会运行用户设置的回调函数。如果这个event被设置成*永久的*，它会
继续变为待触发状态。如果不是永久的，它运行完回调函数之后就不会再等待被再次触发。你也可以通过
'deleting'来停止一个正在等待触发的event。也可以用'add'来让event重新等待触发。

Constructing event objects
~~~~~~~~~~~~~~~~~~~~~~~~~~
构造 event 对象
~~~~~~~~~~~~~~~~~~~~~~~~~~

To create a new event, use the event_new() interface.
创建一个event, 可以使用event_new()接口。

.Interface
[code,C]
--------
#define EV_TIMEOUT      0x01
#define EV_READ         0x02
#define EV_WRITE        0x04
#define EV_SIGNAL       0x08
#define EV_PERSIST      0x10
#define EV_ET           0x20

typedef void (*event_callback_fn)(evutil_socket_t, short, void *);

struct event *event_new(struct event_base *base, evutil_socket_t fd,
    short what, event_callback_fn cb,
    void *arg);

void event_free(struct event *event);
--------

The event_new() function tries to allocate and construct a new event
for use with 'base'.  The 'what' argument is a set of the flags listed
above.  (Their semantics are described below.)  If 'fd' is
nonnegative, it is the file that we'll observe for read or write
events.  When the event is active, Libevent will invoke the provided
'cb' function, passing it as arguments: the file descriptor 'fd', a
bitfield of _all_ the events that triggered, and the value that was passed
in for 'arg' when the function was constructed.

event_new()函数尝试分配并初始化一个供'base'使用的event。'what'参数是一组上面列出来的
枚举。(他们的意思在下面说明。) 如果'fd'参数非否，那它就是我们将要检测可读可写事件的文件描
述符。当event被激活，Libevent会调用用户提供的回调函数'cb'，并传递给它参数：文件描述符'fd'
，还有一个标记代表event被哪些条件触发，以及回调函数构造时用户传递的'arg'参数。

On an internal error, or invalid arguments, event_new() will return NULL.

如果有内部错误或者传参错误，event_new()会返回NULL。

All new events are initialized and non-pending.  To make an event
pending, call event_add() (documented below).

所有新创建的events都是初始化好但是没有进入待触发状态的。为了让一个event进入待触发状态，
需要调用event_add()函数。

To deallocate an event, call event_free().  It is safe to call
event_free() on an event that is pending or active: doing so makes the
event non-pending and inactive before deallocating it.

为了销毁一个event，需要调用event_free()。不管event是待激活状态还是激活状态，调用
event_free()都是安全的：这么做可以保证event销毁前是未进入待激活状态并且是未激活的。

.Example
[code,C]
--------
#include <event2/event.h>

void cb_func(evutil_socket_t fd, short what, void *arg)
{
        const char *data = arg;
        printf("Got an event on socket %d:%s%s%s%s [%s]",
            (int) fd,
            (what&EV_TIMEOUT) ? " timeout" : "",
            (what&EV_READ)    ? " read" : "",
            (what&EV_WRITE)   ? " write" : "",
            (what&EV_SIGNAL)  ? " signal" : "",
            data);
}

void main_loop(evutil_socket_t fd1, evutil_socket_t fd2)
{
        struct event *ev1, *ev2;
        struct timeval five_seconds = {5,0};
        struct event_base *base = event_base_new();

        /* The caller has already set up fd1, fd2 somehow, and make them
           nonblocking. */

        ev1 = event_new(base, fd1, EV_TIMEOUT|EV_READ|EV_PERSIST, cb_func,
           (char*)"Reading event");
        ev2 = event_new(base, fd2, EV_WRITE|EV_PERSIST, cb_func,
           (char*)"Writing event");

        event_add(ev1, &five_seconds);
        event_add(ev2, NULL);
        event_base_dispatch(base);
}
--------

The above functions are defined in <event2/event.h>, and first
appeared in Libevent 2.0.1-alpha.  The event_callback_fn type
first appeared as a typedef in Libevent 2.0.4-alpha.

上面的函数都定义在<event2/event.h>中，首次出现在Libevent 2.0.4-alpha中。

The event flags
^^^^^^^^^^^^^^^

event 触发标记
^^^^^^^^^^^^^^^

EV_TIMEOUT::
    This flag indicates an event that becomes active after a timeout
    elapses.

    The EV_TIMEOUT flag is ignored when constructing an event: you
    can either set a timeout when you add the event, or not.  It is
    set in the 'what' argument to the callback function when a timeout
    has occurred.

EV_TIMEOUT::
    这个标记表明这个event将会在一段时间延时后会被触发。

    EV_TIMEOUT标记在event被创建初始化时会被忽略：你可以在add这个event的时候设置
    一个延时时间。当延时事件发生时这个标记传递给回调函数的'what'参数中。

EV_READ::
    This flag indicates an event that becomes active when the provided
    file descriptor is ready for reading.

EV_READ::
    这个标记表明一个event会在关联的文件描述符上有可读事件时被激活触发。

EV_WRITE::
    This flag indicates an event that becomes active when the provided
    file descriptor is ready for writing.

EV_WRITE::
    这个标记表明一个event会在关联的文件描述符上有可写事件时被激活触发。

EV_SIGNAL::
    Used to implement signal detection.  See "Constructing signal events"
    below.

EV_SIGNAL::
    用来捕获信号。见"构造信号event"

EV_PERSIST::
    Indicates that the event is 'persistent'.  See "About Event
    Persistence" below.

EV_PERSIST::
    表明这个event是长期的。见 "关于永久event"

EV_ET::
    Indicates that the event should be edge-triggered, if the
    underlying event_base backend supports edge-triggered events.
    This affects the semantics of EV_READ and EV_WRITE.

EV_ET::
    表明这个event的触发方式为电平触发，并且需要event_base的底层方法支持电平触发。
    这个效果对EV_READ 和 EV_WRITE有效。

Since Libevent 2.0.1-alpha, any number of events may be pending for
the same conditions at the same time.  For example, you may have two
events that will become active if a given fd becomes ready to read.
The order in which their callbacks are run is undefined.

自从Libevent 2.0.1-alpha开始，任意数量的events可以在同一时刻被同一个条件触发。
举个例子，当一个文件描述符可读时，你可以有2个events被激活，他们的回调函数被执行的
顺序是不确定的。

These flags are defined in <event2/event.h>.  All have existed since
before Libevent 1.0, except for EV_ET, which was introduced in
Libevent 2.0.1-alpha.

这些标记被定义在<event2/event.h>里。除了EV_ET之外的所有标记都在Libevent 1.0之前
的版本里就存在，EV_ET在Libevent 2.0.1-alpha版本中引入。

About Event Persistence
^^^^^^^^^^^^^^^^^^^^^^^

关于永久event
^^^^^^^^^^^^^^^^^^^^^^^

By default, whenever a pending event becomes active (because its fd is
ready to read or write, or because its timeout expires), it becomes
non-pending right before its
callback is executed.  Thus, if you want to make the event pending
again, you can call event_add() on it again from inside
the callback function.

通常情况下，当一个event被激活之后(比如它的fd可读可写，又比如它的定时器到期)，它在对应的
回调函数被执行前将不再处于新的待激活状态。这样的话，如果你希望让这个event重新处于待激活
状态，你就需要在回调函数里再次调用event_add()函数。

If the EV_PERSIST flag is set on an event, however, the event is
'persistent.'  This means that event remains pending even when its
callback is activated.  If you want to make it non-pending from within its
callback, you can call event_del() on it.

但是如果这个event设置了EV_PERSIST标记，那么这个event将是'永久的'。这就意味着这个event
被激活执行回调函数之后会继续等待被再次激活。这时候如果你希望让event不再被激活，则需要调用
手动调用event_del()。

The timeout on a persistent event resets whenever the event's callback
runs.  Thus, if you have an event with flags EV_READ|EV_PERSIST and a
timeout of five seconds, the event will become active:

  - Whenever the socket is ready for reading.
  - Whenever five seconds have passed since the event last became
    active.

一个永久event上的定时设置会在event的回调函数运行后被重置。比如，如果你有一个带有
EV_READ|EV_PERSIST标记的event，并且设置了5秒后运行，那么这个event将会被下面条件激活:

  - 当socket可读就绪。
  - 当event距上一次被激活时间达到5秒了。


Creating an event as its own callback argument
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

创建一个event作为它自己回调函数的参数
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Frequently, you might want to create an event that receives itself as a
callback argument.  You can't just pass a pointer to the event as an argument
to event_new(), though, because it does not exist yet.  To solve this problem,
you can use event_self_cbarg().

通常你可以希望创建一个将自身作为回调函数参数的event。这里你不能通过event_new()的时候
直接传递一个指向event的指针作为参数，因为这个时候event还未被创建。为了解决这个总是，你可以
使用event_self_cbarg()。

.Interface
[code,C]
-----
void *event_self_cbarg();
-----

The event_self_cbarg() function returns a "magic" pointer which, when passed
as an event callback argument, tells event_new() to create an event receiving
itself as its callback argument.

event_self_cbarg()函数返回一个 "魔法" 指针，当传递给event作为回调函数参数的时候，告诉
event_new()创建event的时候将自己作为回调函数的参数。

.Example
[code,C]
--------
#include <event2/event.h>

static int n_calls = 0;

void cb_func(evutil_socket_t fd, short what, void *arg)
{
    struct event *me = arg;

    printf("cb_func called %d times so far.\n", ++n_calls);

    if (n_calls > 100)
       event_del(me);
}

void run(struct event_base *base)
{
    struct timeval one_sec = { 1, 0 };
    struct event *ev;
    /* We're going to set up a repeating timer to get called called 100
       times. */
    ev = event_new(base, -1, EV_PERSIST, cb_func, event_self_cbarg());
    event_add(ev, &one_sec);
    event_base_dispatch(base);
}
--------

This function can also be used with event_new(), evtimer_new(),
evsignal_new(), event_assign(), evtimer_assign(), and evsignal_assign().  It
won't work as a callback argument for non-events, however.

The event_self_cbarg() function was introduced in Libevent 2.1.1-alpha.

这个函数可以被用于event_new(), evtimer_new(), evsignal_new(), event_assign(),
evtimer_assign(), 以及 evsignal_assign()等函数。它不能被用于event以外其他回调函数的参数。

event_self_cbarg()函数自Libevent 2.1.1-alpha版本引入。

Timeout-only events
^^^^^^^^^^^^^^^^^^^

定时器events
^^^^^^^^^^^^^^^^^^^

As a convenience, there are a set of macros beginning with evtimer_ that
you can use in place of the event_* calls to allocate and manipulate
pure-timeout events.  Using these macros provides no benefit beyond
improving the clarity of your code.

为了方便，Libevent里面定义了一些以evtimer_开头的宏来代替event_*函数来构造和操作单纯
的定时器events。使用这些宏并不会为你带来任何好处，只是能提高你代码的可读性。

.Interface
[code,C]
--------
#define evtimer_new(base, callback, arg) \
    event_new((base), -1, 0, (callback), (arg))
#define evtimer_add(ev, tv) \
    event_add((ev),(tv))
#define evtimer_del(ev) \
    event_del(ev)
#define evtimer_pending(ev, tv_out) \
    event_pending((ev), EV_TIMEOUT, (tv_out))
--------

These macros have been present since Libevent 0.6, except for evtimer_new(),
which first appeared in Libevent 2.0.1-alpha.

这些宏提出自Libevent 0.6版，除了evtimer_new()函数，它是从Libevent 2.0.1-alpha版
开始出现的。

Constructing signal events
^^^^^^^^^^^^^^^^^^^^^^^^^^

构造信号处理events
^^^^^^^^^^^^^^^^^^^^^^^^^^

Libevent can also watch for POSIX-style signals.  To construct a
handler for a signal, use:

Libevent也可以监测POSIX风格的信号。为了构造一个信号处理器, 可以使用:

.Interface
[code,C]
--------
#define evsignal_new(base, signum, cb, arg) \
    event_new(base, signum, EV_SIGNAL|EV_PERSIST, cb, arg)
--------

The arguments are as for event_new, except that we provide a signal
number instead of a file descriptor.

参数和event_new差不多，除了我们需要提供一个代表信号的值来取代文件描述符。

//BUILD: SKIP
.Example
[code,C]
--------
struct event *hup_event;
struct event_base *base = event_base_new();

/* call sighup_function on a HUP signal */
hup_event = evsignal_new(base, SIGHUP, sighup_function, NULL);
--------

Note that signal callbacks are run in the event loop after the signal
occurs, so it is safe for them to call functions that you are not
supposed to call from a regular POSIX signal handler.

注意, 信号回调函数是运行在当信号触发之后的事件循环里的，所以回调函数是安全的，你
不用担心回调会在普通的POSIX信号处理函数中被调用。

WARNING: Don't set a timeout on a signal event.  It might not be
supported.  [FIXME: is this true?]

警告: 不要在一个信号event上设置定时器。暂时是不支持的。

There are also a set of convenience macros you can use when working
with signal events.

同样的Libevent里也有一系列宏来简化你使用信号events的方式。

.Interface
[code,C]
--------
#define evsignal_add(ev, tv) \
    event_add((ev),(tv))
#define evsignal_del(ev) \
    event_del(ev)
#define evsignal_pending(ev, what, tv_out) \
    event_pending((ev), (what), (tv_out))
--------

The evsignal_* macros have been present since Libevent 2.0.1-alpha.
Prior versions called them signal_add(), signal_del(), and so on.

evsignal_*系列宏出现自Libevent 2.0.1-alpha版本。之前版本中可以使用singal_add()，
signal_del()等函数。

Caveats when working with signals
+++++++++++++++++++++++++++++++++

使用singal时需要注意的点
+++++++++++++++++++++++++++++++++

With current versions of Libevent, with most backends, only one event_base
per process at a time can be listening for signals.  If you add signal events
to two event_bases at once ---even if the signals are different!--- only one
event_base will receive signals.

在Libevent当前的版本中，大部分底层方法，一个进程中同一时刻只能使用一个event_base来监听信号。
如果你同时向2个event_base中添加信号events， ---甚至用的是2个不同的信号!--- 只有一个
event_base可以收到信号。

The kqueue backend does not have this limitation.

但是底层用kqueue的话没有这个限制。

Setting up events without heap-allocation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

不使用event_new()构建events。
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For performance and other reasons, some people like to allocate events
as a part of a larger structure.  For each use of the event, this
saves them:

   - The memory allocator overhead for allocating a small object on
     the heap.
   - The time overhead for dereferencing the pointer to the
     struct event.
   - The time overhead from a possible additional cache miss if the
     event is not already in the cache.

为了性能和一些其他原因，有人希望可以将event作为一个较大的结构体的成员
变量。跟使用单个event想比，可以节约下面几点:
   - 用new创建小结构体带来的内存碎片消耗。
   - 用event指针取值带来的时间消耗。
   - 缓存未命中带来的时间消耗。

Using this method risks breaking binary compatibility with other
versions of of Libevent, which may have different sizes for the event
structure.

使用这些函数会打破与其他版本Libevent的二进制兼容，有可能会造成event的大小
不一致。

These are _very_ small costs, and do not matter for most applications.
You should just stick to using event_new() unless you *know* that
you're incurring a significant performance penalty for heap-allocating
your events.  Using event_assign() can cause hard-to-diagnose errors
with future versions of Libevent if they use a larger event structure
than the one you're building with.

其实原来用event_new创建event的方式只有_非常_小的消耗，对于大部分应用来说
无关紧要。你最好使用event_new()来创建event，除非你*明确*你正在遭受由使用
event_new()带来的严重性能问题。如果将event作为结构体成员变量，在不同版本
中使用event_assign()可能会导致一些隐性错误。

.Interface
[code,C]
--------
int event_assign(struct event *event, struct event_base *base,
    evutil_socket_t fd, short what,
    void (*callback)(evutil_socket_t, short, void *), void *arg);
--------

All the arguments of event_assign() are as for event_new(), except for
the 'event' argument, which must point to an uninitialized event.  It returns
0 on success, and -1 on an internal error or bad arguments.

event_assign()的大部分参数和event_new()一样，除了'event'参数，它是一个指向
未初始化的event的指针。调用成功返回0，失败或者参数错误返回-1。

.Example
[code,C]
--------
#include <event2/event.h>
/* Watch out!  Including event_struct.h means that your code will not
 * be binary-compatible with future versions of Libevent. */
/* 注意！ 包含event_struct.h头文件意味着你的代码将不能和
 * 未来版本的Libevent二进制兼容。 */
#include <event2/event_struct.h>
#include <stdlib.h>

struct event_pair {
         evutil_socket_t fd;
         struct event read_event;
         struct event write_event;
};
void readcb(evutil_socket_t, short, void *);
void writecb(evutil_socket_t, short, void *);
struct event_pair *event_pair_new(struct event_base *base, evutil_socket_t fd)
{
        struct event_pair *p = malloc(sizeof(struct event_pair));
        if (!p) return NULL;
        p->fd = fd;
        event_assign(&p->read_event, base, fd, EV_READ|EV_PERSIST, readcb, p);
        event_assign(&p->write_event, base, fd, EV_WRITE|EV_PERSIST, writecb, p);
        return p;
}
--------

You can also use event_assign() to initialize stack-allocated or
statically allocated events.

你也可以用event_assign()来初始化栈上创建的以及静态的event结构体。

.WARNING
Never call event_assign() on an event that is already pending in an
event base.  Doing so can lead to extremely hard-to-diagnose
errors.  If the event is already initialized and pending, call
event_del() on it *before* you call event_assign() on it again.

.警告
绝对不要对一个已经追加到event_base中处于待激活状态的event使用event_assign()函数。
这么做会导致非常难以察觉的错误。如果event已经初始化完成并且处于待激活状态，
在你在这个event上使用event_assign() *之前* 先使用event_del()来删除它。

There are convenience macros you can use to event_assign() a timeout-only or
a signal event:

下面有一些宏来方便你使用event_assign()来初始化一个定时器或信号event:

.Interface
[code,C]
--------
#define evtimer_assign(event, base, callback, arg) \
    event_assign(event, base, -1, 0, callback, arg)
#define evsignal_assign(event, base, signum, callback, arg) \
    event_assign(event, base, signum, EV_SIGNAL|EV_PERSIST, callback, arg)
--------

If you need to use event_assign() *and* retain binary compatibility with
future versions of Libevent, you can ask the Libevent library to tell
you at runtime how large a 'struct event' should be:

如果你需要使用event_assign() *并且* 需要与未来版本保持二进制兼容，那么你可以
运行时向Libevent库请求'event结构体'的具体大小:

.Interface
[code,C]
-----
size_t event_get_struct_event_size(void);
-----

This function returns the number of bytes you need to set aside for
a struct event.  As before, you should only be using this function if
you know that heap-allocation is actually a significant problem in your
program, since it can make your code much harder to read and write.

这个函数返回需要为event预留内存大小的字节数。跟之前一样，你需要明确知道
堆构建event是造成你程序里严重问题根源的时候再去使用它，因为它会把你代码的
可读性变差。

Note that event_get_struct_event_size() may in the future give you a value
_smaller_ than 'sizeof(struct event)'.  If this happens, it means that
any extra bytes at the end of 'struct event' are only padding bytes reserved
for use by a future version of Libevent.

注意event_get_struct_event_size()可能会在未来版本获得比'sizeof(struct event)' _小_
的数值。如果发生这种情况，意味着'event'结构体最后的那些额外字节是为了给未来版本的
Libevent做保留的填充字节。

Here's the same example as above, but instead of relying on the size
of 'struct event' from event_struct.h, we use event_get_struct_size()
to use the correct size at runtime.

这里有一个和上面一样的例子，但是用event_get_struct_size()获取运行时event大小，来取代
event_struct.h头文件中event结构体的大小。

.Example
[code,C]
--------
#include <event2/event.h>
#include <stdlib.h>

/* When we allocate an event_pair in memory, we'll actually allocate
 * more space at the end of the structure.  We define some macros
 * to make accessing those events less error-prone. */
/* 当我们内存中申请一个event_pair结构，我们实际上会在结构体后面
 * 申请更多的内存来保存event。我们定义一些宏
 * 来不容易出错地访问这些event。*/
struct event_pair {
         evutil_socket_t fd;
};

/* Macro: yield the struct event 'offset' bytes from the start of 'p' */
/* 宏: 返回指针'p'偏移'offset'字节的地址作为event指针。 */
#define EVENT_AT_OFFSET(p, offset) \
            ((struct event*) ( ((char*)(p)) + (offset) ))
/* Macro: yield the read event of an event_pair */
/* 宏: 返回event_pair中读事件event结构的地址 */
#define READEV_PTR(pair) \
            EVENT_AT_OFFSET((pair), sizeof(struct event_pair))
/* Macro: yield the write event of an event_pair */
/* 宏: 返回event_pair中写事件event结构的地址 */
#define WRITEEV_PTR(pair) \
            EVENT_AT_OFFSET((pair), \
                sizeof(struct event_pair)+event_get_struct_event_size())

/* Macro: yield the actual size to allocate for an event_pair */
/* 宏: 返回为event_pair结构体申请内存的实际大小 */
#define EVENT_PAIR_SIZE() \
            (sizeof(struct event_pair)+2*event_get_struct_event_size())

void readcb(evutil_socket_t, short, void *);
void writecb(evutil_socket_t, short, void *);
struct event_pair *event_pair_new(struct event_base *base, evutil_socket_t fd)
{
        struct event_pair *p = malloc(EVENT_PAIR_SIZE());
        if (!p) return NULL;
        p->fd = fd;
        event_assign(READEV_PTR(p), base, fd, EV_READ|EV_PERSIST, readcb, p);
        event_assign(WRITEEV_PTR(p), base, fd, EV_WRITE|EV_PERSIST, writecb, p);
        return p;
}
--------

The event_assign() function defined in <event2/event.h>.  It has existed
since Libevent 2.0.1-alpha.  It has returned an int since 2.0.3-alpha;
previously, it returned void.  The event_get_struct_event_size()
function was introduced in Libevent 2.0.4-alpha.  The event structure
itself is defined in <event2/event_struct.h>.

event_assign()函数字义在<event2/event.h>头文件中。出现自Libevent 2.0.1-alpha版本。
2.0.3-alpha版本开始，它返回一个int类型。之前没有返回值。event_get_struct_event_size()
函数始于Libevent 2.0.4-alpha版本。event结构体是定义在<event2/event_struct.h>头文件中的。

Making events pending and non-pending
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

设置events等待激活和取消等待激活
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Once you have constructed an event, it won't actually do anything
until you have made it 'pending' by adding it.  You do this with
event_add:

一旦你构造了一个event，它实际上还不能做任何事，除非你将它add到event_base中使它
处于待激活状态。你可以使用event_add来这么做:

.Interface
[code,C]
--------
int event_add(struct event *ev, const struct timeval *tv);
--------

Calling event_add on a non-pending event makes it pending in its
configured base.  The function returns 0 on success, and -1 on
failure.  If 'tv' is NULL, the event is added with no timeout.
Otherwise, 'tv' is the size of the timeout in seconds and
microseconds.

对一个未处于等待激活状态的event调用event_add会让它加入到配置了的event_base中。
函数成功时返回0，失败返回-1。如果'tv'为空，这个event将不会设置超时。相反的，
'tv'包含超时设置的秒数和毫秒数。

If you call event_add() on an event that is _already_ pending, it will
leave it pending, and reschedule it with the provided timeout.  If the
event is already pending, and you re-add it with the timeout NULL,
event_add() will have no effect.

如果你对一个*已经*处于等激活状态的event调用event_add()，不会改变event的状态，
并且如果给了超时的话会重置超时时间。如果event已经在等待激活，并且你用超时时间
参数为空来重新add它，event_add()函数不会有任何效果。

NOTE: Do not set 'tv' to the time at which you want the timeout to
run.  If you say "tv->tv_sec = time(NULL)+10;" on 1 January 2010, your
timeout will wait 40 years, not 10 seconds.

注意：不要将参数'tv'设置成你希望程序运行的时间。比如你在2010年1月1号用
"tv->tv_sec = time(NULL)+10;", 那么你的超时将会在40年后过期，而非10秒后过期。

.Interface
[code,C]
--------
int event_del(struct event *ev);
--------

Calling event_del on an initialized event makes it non-pending and
non-active.  If the event was not pending or active, there is no
effect.  The return value is 0 on success, -1 on failure.

对一个初始化好的event调用event_del可以使它取消等待激活状态。如果event并未
正在等待或者已被激活，这么做没有任何效果。函数成功时返回0，失败返回-1。

NOTE: If you delete an event after it becomes active but before
its callback has a chance to execute, the callback will not be
executed.

注意：如果你在一个event激活后且它的回调函数被执行前删除一个event，那么它的
回调函数将不会被执行。

.Interface
[code,C]
--------
int event_remove_timer(struct event *ev);
---------

Finally, you can remove a pending event's timeout completely without
deleting its IO or signal components.  If the event had no timeout
pending, event_remove_timer() has no effect.  If the event had only a
timeout but no IO or signal component, event_remove_timer() has the
same effect as event_del(). The return value is 0 on success, -1 on
failure.

最后，使用event_remove_timer可以让你在不影响event中信号或者IO组件的情况
下，移除一个已处于等待激活的event的超时设定。如果event没有设置超时，
event_remove_timer()函数没有任何效果。如果event只有超时设定而没有IO或者
信号组件，那么event_remove_timer和event_del的效果一样。函数成功时返回0，
失败时返回-1。

These are defined in <event2/event.h>; event_add() and event_del()
have existed since Libevent 0.1; event_remove_timer() was added in
2.1.2-alpha.

这些函数被定义在<event2/event.h>头文件中，event_add() 和 event_del()出现自
Libevent 0.1版。event_remove_timer()是在2.1.2-alpha版中新增加的。

Events with priorities
~~~~~~~~~~~~~~~~~~~~~~

事件的优先级
~~~~~~~~~~~~~~~~~~~~~~

When multiple events trigger at the same time, Libevent does not
define any order with respect to when their callbacks will be
executed.  You can define some events as more important than others by
using priorities.

当有多个event在同一时刻触发，Libevent不会去定义他们的回调函数被执行的先后顺序。
你可以通过定义优先级来让一些event比其他的event更重要。

As discussed in an earlier section, each event_base has one or more
priority values associated with it.  Before adding an event to the
event_base, but after initializing it, you can set its priority.

在之前一个章节的讨论过，每个event_base关联了一个或者多个优先级。在添加一个event到
event_base之前，在event初始化之后，你可以设置它的优先级。

.Interface
[code,C]
----------
int event_priority_set(struct event *event, int priority);
----------

The priority of the event is a number between 0 and the number of
priorities in an event_base, minus 1.  The function returns 0 on
success, and -1 on failure.

event的优先级是一个从0到event_base优先级总数-1的数值。这个函数成功时返回0，失败返回-1。

When multiple events of multiple priorities become active, the
low-priority events are not run.  Instead, Libevent runs the high
priority events, then checks for events again.  Only when no
high-priority events are active are the low-priority events run.

当拥有多个优先级的多个event被同时激活时，低优先级的event不会马上运行。而Libevent会运行高优先级的
event，然后再次检查event。直到没有高优先级的event激活时才会运行低优先级的event。

.Example
[code,C]
----------
#include <event2/event.h>

void read_cb(evutil_socket_t, short, void *);
void write_cb(evutil_socket_t, short, void *);

void main_loop(evutil_socket_t fd)
{
  struct event *important, *unimportant;
  struct event_base *base;

  base = event_base_new();
  event_base_priority_init(base, 2);
  /* Now base has priority 0, and priority 1 */
  /* 现在base有优先级0和1 */
  important = event_new(base, fd, EV_WRITE|EV_PERSIST, write_cb, NULL);
  unimportant = event_new(base, fd, EV_READ|EV_PERSIST, read_cb, NULL);
  event_priority_set(important, 0);
  event_priority_set(unimportant, 1);

  /* Now, whenever the fd is ready for writing, the write callback will
     happen before the read callback.  The read callback won't happen at
     all until the write callback is no longer active. */
  /* 现在，只要fd准备可写的时候，写数据的回调函数就会在读数据之前被执行。而读数据不会
     被执行，除非写事件不再被激活。*/
}
----------

When you do not set the priority for an event, the default is the
number of queues in the event base, divided by 2.

TODO TEST
当你没有设置event的优先级的时候，它的默认优先级是event_base中优先级队列总数除以2。

This function is declared in <event2/event.h>.  It has existed since
Libevent 1.0.

这个函数被定义在<event2/event.h>头文件里，首次出现自Libevent 1.0版。

Inspecting event status
~~~~~~~~~~~~~~~~~~~~~~~

检查事件状态
~~~~~~~~~~~~~~~~~~~~~~~

Sometimes you want to tell whether an event has been added, and check
what it refers to.

有时候你你可能需要知道一个event是否已被添加,并且检查它绑定了什么事件。

.Interface
[code,C]
--------
int event_pending(const struct event *ev, short what, struct timeval *tv_out);

#define event_get_signal(ev) /* ... */
evutil_socket_t event_get_fd(const struct event *ev);
struct event_base *event_get_base(const struct event *ev);
short event_get_events(const struct event *ev);
event_callback_fn event_get_callback(const struct event *ev);
void *event_get_callback_arg(const struct event *ev);
int event_get_priority(const struct event *ev);

void event_get_assignment(const struct event *event,
        struct event_base **base_out,
        evutil_socket_t *fd_out,
        short *events_out,
        event_callback_fn *callback_out,
        void **arg_out);
--------

The event_pending function determines whether the given event is
pending or active.  If it is, and any of the flags EV_READ, EV_WRITE,
EV_SIGNAL, and EV_TIMEOUT are set in the 'what' argument, the function
returns all of the flags that the event is currently pending or active
on.  If 'tv_out' is provided, and EV_TIMEOUT is set in 'what', and the
event is currently pending or active on a timeout, then 'tv_out' is
set to hold the time when the event's timeout will expire.

event_pending函数能够确定给定的event是否正在等待激活或者已经被激活。如果
是，并且EV_READ, EV_WRITE, EV_SIGNAL, 和 EV_TIMEOUT等任意标记被设置到参数
'what'中，函数会返回一个数，表示event是否正在等待其中的某几个条件或者已被
某几个条件激活，这个数是这些条件的按位或。如果提供了'tv_out'参数，并且标记
EV_TIMEOUT被设置到'what'参数中，那么'tv_out'参数会被设置成event还有多少时间
触发。

The event_get_fd() and event_get_signal() functions return the
configured file descriptor or signal number for an event.  The
event_get_base() function returns its configured event_base.  The
event_get_events() function returns the event flags (EV_READ, EV_WRITE,
etc) of the event.  The event_get_callback() and
event_get_callback_arg() functions return the callback function and
argument pointer.  The event_get_priority() function returns the event's
currently assigned priority.

event_get_fd() 和 event_get_signal() 函数返回一个event中设置的文件描述符或
信号值。event_get_base() 函数返回event添加到的那个event_base。event_get_events()
函数返回event设置监听的事件类型标记(EV_READ, EV_WRITE等)。event_get_callback()
和 event_get_callback_arg() 函数返回event的回调函数和自定义参数指针。
event_get_priority() 函数返回event当前分配的优先级。

The event_get_assignment() function copies all of the assigned fields of
the event into the provided pointers.  If any of the pointers is NULL,
it is ignored.

event_get_assignment() 函数拷贝event参数里的所有字段到该函数给定参数里的指针上。
如果哪个参数没有提供指针，那么那个字段会被忽略。

.Example
[code,C]
------
#include <event2/event.h>
#include <stdio.h>

/* Change the callback and callback_arg of 'ev', which must not be
 * pending. */
/* 改变参数'ev'的回调函数和回调函数参数, 此时'ev'应该还不能开始监听
 * 事件等待激活。 */
int replace_callback(struct event *ev, event_callback_fn new_callback,
    void *new_callback_arg)
{
    struct event_base *base;
    evutil_socket_t fd;
    short events;

    int pending;

    pending = event_pending(ev, EV_READ|EV_WRITE|EV_SIGNAL|EV_TIMEOUT,
                            NULL);
    if (pending) {
        /* We want to catch this here so that we do not re-assign a
         * pending event.  That would be very very bad. */
        /* 我们不应该到达这里因为我们不能重新分配一个已经处于等待激活状态
         * 的event。这是很不好的。*/
        fprintf(stderr,
                "Error! replace_callback called on a pending event!\n");
        return -1;
    }

    event_get_assignment(ev, &base, &fd, &events,
                         NULL /* ignore old callback */ ,
                         NULL /* ignore old callback argument */);

    event_assign(ev, base, fd, events, new_callback, new_callback_arg);
    return 0;
}
------

These functions are declared in <event2/event.h>.  The event_pending()
function has existed since Libevent 0.1.  Libevent 2.0.1-alpha introduced
event_get_fd() and event_get_signal().  Libevent 2.0.2-alpha introduced
event_get_base(). Libevent 2.1.2-alpha added event_get_priority().  The
others were new in Libevent 2.0.4-alpha.

这些函数被定义在<event2/event.h>头文件中。event_pending() 函数出现自Libevent 0.1
版。Libevent 2.0.1-alpha版引进了event_get_fd() 和 event_get_signal()。
Libevent 2.0.2-alpha版引进了event_get_base()。Libevent 2.1.2-alpha版添加了
event_get_priority()。其他函数新出现在Libevent 2.0.4-alpha版本中。

Finding the currently running event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

查看当前正在运行的event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For debugging or other purposes, you can get a pointer to the currently
running event.

为了调试或者其他目的，你可能希望获得当前正在运行的event的指针。

.Interface
[code,C]
-----
struct event *event_base_get_running_event(struct event_base *base);
-----

Note that this function's behavior is only defined when it's called from
within the provided event_base's loop.  Calling it from another thread is not
supported, and can cause undefined behavior.

需要注意的是这个函数只能作用于提供的event_base的主循环里，在其他地方或者另外的
线程调用都不行，会带来未知错误。

This function is declared in <event2/event.h>.  It was introduced in Libevent
2.1.1-alpha.

这个函数定义在<event2/event.h>头文件中。自Libevent 2.1.1-alpha版本引入。

Configuring one-off events
~~~~~~~~~~~~~~~~~~~~~~~~~~

设置一次性event
~~~~~~~~~~~~~~~~~~~~~~~~~~

If you don't need to add an event more than once, or delete it once it
has been added, and it doesn't have to be persistent, you can use
event_base_once().

如果你不需要多次添加一个event，或者添加完之后马上要删除它，并且它不是永久的，
那你可以使用event_base_once()。

.Interface
[code,C]
--------
int event_base_once(struct event_base *, evutil_socket_t, short,
  void (*)(evutil_socket_t, short, void *), void *, const struct timeval *);
--------

This function's interface is the same as event_new(), except that it
does not support EV_SIGNAL or EV_PERSIST.  The scheduled event is
inserted and run with the default priority.  When the callback is
finally done, Libevent frees the internal event structure itself.
The return value is 0 on success, -1 on failure.

这个函数接口跟 event_new() 一样，除了它不支持EV_SIGNAL和EV_PERSIST。这个计划中的
event会以默认的优先级插入和运行。当它的回调函数运行完成之后，Libevent会自动释放这个
内部的event结构体。这个函数成功时返回0，失败返回-1。

Events inserted with event_base_once cannot be deleted or manually
activated: if you want to be able to cancel an event, create it with the
regular event_new() or event_assign() interfaces.

通过event_base_once添加的event不能被删除或者手动触发: 如果你希望能够删除一个event，
请使用通常的 event_new() 或 event_assign() 接口。

Note also that at up to Libevent 2.0, if the event is never triggered, the
internal memory used to hold it will never be freed.  Starting in Libevent
2.1.2-alpha, these events _are_ freed when the event_base is freed, even if
they haven't activated, but still be aware: if there's some storage
associated with their callback arguments, that storage won't be released
unless your program has done something to track and release it.

注意在Libevent 2.0版之前，如果一个一次性event从来没有被激活过，那这个内部event将
永远不会从内存上释放。从Libevent 2.1.2-alpha开始，这些event的内存会在event_base被释放
的时候被释放。

Manually activating an event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

手动激活一个event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Rarely, you may want to make an event active even though its
conditions have not triggered.

少部分情况下，你可能希望在一个event的条件未发生的情况下手动激活一个event。

.Interface
[code,C]
--------
void event_active(struct event *ev, int what, short ncalls);
--------

This function makes an event 'ev' become active with the flags 'what'
(a combination of EV_READ, EV_WRITE, and EV_TIMEOUT).  The event does
not need to have previously been pending, and activating it does not
make it pending.

这个函数可以使'ev'参数指向的event通过'what'参数的标记激活，(EV_READ, EV_WRITE
和 EV_TIMEOUT的组合)。这个event不需要事件设置成等待激活状态，手动激活它也不会让
他变成等待激活。

Warning: calling event_active() recursively on the same event may result in
resource exhaustion. The following snippet of code is an example of how
event_active can be used incorrectly.

警告: 在一个event上递归地调用event_active()函数会导致资源耗尽。下面的代码片断是一个
不正确使用event_active的坏例子。

//BUILD: INC:event2/event.h
.Bad Example: making an infinite loop with event_active()
[code,C]
--------
struct event *ev;

static void cb(int sock, short which, void *arg) {
        /* Whoops: Calling event_active on the same event unconditionally
           from within its callback means that no other events might not get
           run! */

	event_active(ev, EV_WRITE, 0);
}

int main(int argc, char **argv) {
	struct event_base *base = event_base_new();

	ev = event_new(base, -1, EV_PERSIST | EV_READ, cb, NULL);

	event_add(ev, NULL);

	event_active(ev, EV_WRITE, 0);

	event_base_loop(base, 0);

	return 0;
}
--------

This creates a situation where the event loop is only executed once and calls
the function "cb" forever.

这样用会产生一种情况，一个event循环只执行了一次但是会无限循环'cb'回调。

//BUILD: INC:event2/event.h
.Example: Alternative solution to the above problem using timers
[code,C]
--------

struct event *ev;
struct timeval tv;

static void cb(int sock, short which, void *arg) {
   if (!evtimer_pending(ev, NULL)) {
       event_del(ev);
       evtimer_add(ev, &tv);
   }
}

int main(int argc, char **argv) {
   struct event_base *base = event_base_new();

   tv.tv_sec = 0;
   tv.tv_usec = 0;

   ev = evtimer_new(base, cb, NULL);

   evtimer_add(ev, &tv);

   event_base_loop(base, 0);

   return 0;
}
--------

//BUILD: INC:event2/event.h
.Example: Alternative solution to the above problem using event_config_set_max_dispatch_interval()
[code,C]
--------
struct event *ev;

static void cb(int sock, short which, void *arg) {
	event_active(ev, EV_WRITE, 0);
}

int main(int argc, char **argv) {
        struct event_config *cfg = event_config_new();
        /* Run at most 16 callbacks before checking for other events. */
        event_config_set_max_dispatch_interval(cfg, NULL, 16, 0);
	struct event_base *base = event_base_new_with_config(cfg);
	ev = event_new(base, -1, EV_PERSIST | EV_READ, cb, NULL);

	event_add(ev, NULL);

	event_active(ev, EV_WRITE, 0);

	event_base_loop(base, 0);

	return 0;
}
--------


This function is defined in <event2/event.h>.  It has existed
since Libevent 0.3.

这个函数定义在<event2/event.h>头文件中。出现自Libevent 0.3版本。

Optimizing common timeouts
~~~~~~~~~~~~~~~~~~~~~~~~~~

Current versions of Libevent use a binary heap algorithm to keep track
of pending events' timeouts.  A binary heap gives performance of order
O(lg n) for adding and deleting each event timeout.  This is optimal if
you're adding events with a randomly distributed set of timeout values,
but not if you have a large number of events with the same timeout.

For example, suppose you have ten thousand events, each of which should
trigger its timeout five seconds after it was added.  In a situation
like this, you could get O(1) performance for each timeout by using a
doubly-linked queue implementation.

Naturally, you wouldn't want to use a queue for all of your timeout
values, since a queue is only faster for constant timeout values.  If
some of the timeouts are more-or-less randomly distributed, then adding
one of those timeouts to a queue would take O(n) time, which would be
significantly worse than a binary heap.

Libevent lets you solve this by placing some of your timeouts in queues,
and others in the binary heap.  To do this, you ask Libevent for a
special "common timeout" timeval, which you then use to add events
having that timeval.  If you have a very large number of events with
a single common timeout, using this optimization should improve
timeout performance.

.Interface
[code,C]
-----
const struct timeval *event_base_init_common_timeout(
    struct event_base *base, const struct timeval *duration);
-----

This function takes as its arguments an event_base, and the duration
of the common timeout to initialize.  It returns a pointer to a special
struct timeval that you can use to indicate that an event should be
added to an O(1) queue rather than the O(lg n) heap.  This special
timeval can be copied or assigned freely in your code.  It will only
work with the specific base you used to construct it.  Do not rely on
its actual contents: Libevent uses them to tell itself which queue to
use.

.Example
[code,C]
-----
#include <event2/event.h>
#include <string.h>

/* We're going to create a very large number of events on a given base,
 * nearly all of which have a ten-second timeout.  If initialize_timeout
 * is called, we'll tell Libevent to add the ten-second ones to an O(1)
 * queue. */
struct timeval ten_seconds = { 10, 0 };

void initialize_timeout(struct event_base *base)
{
    struct timeval tv_in = { 10, 0 };
    const struct timeval *tv_out;
    tv_out = event_base_init_common_timeout(base, &tv_in);
    memcpy(&ten_seconds, tv_out, sizeof(struct timeval));
}

int my_event_add(struct event *ev, const struct timeval *tv)
{
    /* Note that ev must have the same event_base that we passed to
       initialize_timeout */
    if (tv && tv->tv_sec == 10 && tv->tv_usec == 0)
        return event_add(ev, &ten_seconds);
    else
        return event_add(ev, tv);
}
-----

As with all optimization functions, you should avoid using the
common_timeout functionality unless you're pretty sure that it matters
for you.

This functionality was introduced in Libevent 2.0.4-alpha.

Telling a good event apart from cleared memory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Libevent provides functions that you can use to distinguish an
initialized event from memory that has been cleared by setting it to 0
(for example, by allocating it with calloc() or clearing it with
memset() or bzero()).

.Interface
[code,C]
-----
int event_initialized(const struct event *ev);

#define evsignal_initialized(ev) event_initialized(ev)
#define evtimer_initialized(ev) event_initialized(ev)
-----

.Warning
These functions can't reliably distinguish between an initialized event
and a hunk of uninitialized memory.  You should not use them
unless you know that the memory in question is either cleared or
initialized as an event.

Generally, you shouldn't need to use these functions unless you've got a
pretty specific application in mind.  Events returned by event_new() are
always initialized.

.Example
[code,C]
-----
#include <event2/event.h>
#include <stdlib.h>

struct reader {
    evutil_socket_t fd;
};

#define READER_ACTUAL_SIZE() \
    (sizeof(struct reader) + \
     event_get_struct_event_size())

#define READER_EVENT_PTR(r) \
    ((struct event *) (((char*)(r))+sizeof(struct reader)))

struct reader *allocate_reader(evutil_socket_t fd)
{
    struct reader *r = calloc(1, READER_ACTUAL_SIZE());
    if (r)
        r->fd = fd;
    return r;
}

void readcb(evutil_socket_t, short, void *);
int add_reader(struct reader *r, struct event_base *b)
{
    struct event *ev = READER_EVENT_PTR(r);
    if (!event_initialized(ev))
        event_assign(ev, b, r->fd, EV_READ, readcb, r);
    return event_add(ev, NULL);
}
-----

The event_initialized() function has been present since Libevent 0.3.

Obsolete event manipulation functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Pre-2.0 versions of Libevent did not have event_assign() or
event_new().  Instead, you had event_set(), which associated the event
with the "current" base.  If you had more than one base, you needed to
remember to call event_base_set() afterwards to make sure that the
event was associated with the base you actually wanted to use.

.Interface
[code,C]
--------
void event_set(struct event *event, evutil_socket_t fd, short what,
        void(*callback)(evutil_socket_t, short, void *), void *arg);
int event_base_set(struct event_base *base, struct event *event);
--------

The event_set() function was like event_assign(), except for its use
of the current base.  The event_base_set() function changes the base
associated with an event.

There were variants of event_set() for dealing more conveniently with
timers and signals: evtimer_set() corresponded roughly to evtimer_assign(),
and evsignal_set() corresponded roughly to evsignal_assign().

Versions of Libevent before 2.0 used "signal_" as the prefix for the
signal-based variants of event_set() and so on, rather than "evsignal_".
(That is, they had signal_set(), signal_add(), signal_del(),
signal_pending(), and signal_initialized().)  Truly ancient versions of
Libevent (before 0.6) used "timeout_" instead of "evtimer_".  Thus, if you're
doing code archeology, you might see timeout_add(), timeout_del(),
timeout_initialized(), timeout_set(), timeout_pending(), and so on.

In place of the event_get_fd() and event_get_signal() functions, older
versions of Libevent (before 2.0) used two macros called EVENT_FD() and
EVENT_SIGNAL().  These macros inspected the event structure's contents
directly and so prevented binary compatibility between versions; in 2.0 and
later they are just aliases for event_get_fd() and event_get_signal().

Since versions of Libevent before 2.0 did not have
locking support, it wasn't safe to call any of the functions that
change an event's state with respect to a base from outside the thread
running the base.  These include event_add(), event_del(),
event_active(), and event_base_once().

There was also an event_once() function that played the role of
event_base_once(), but used the current base.

The EV_PERSIST flag did not interoperate sensibly with timeouts before
Libevent 2.0. Instead resetting the timeout whenever the event was
activated, the EV_PERSIST flag did nothing with the timeout.

Libevent versions before 2.0 did not support having multiple events
inserted at the same time with the same fd and the same READ/WRITE.
In other words, only one event at a time could be waiting for read on
each fd, and only one event at a time could be waiting for write on
each fd.
